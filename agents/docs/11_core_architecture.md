# コアアーキテクチャ

## 構造

Agent は二つの世界で構成される。

```
┌─────────────────────────────────────────────────────────┐
│ Agent の世界（内側）                                     │
│                                                         │
│   設定 ──→ ループ ──→ 判定                              │
│                                                         │
│   ┌───────────────────────────────────────────────┐   │
│   │ while (!complete) {                            │   │
│   │   prompt = 解決()                              │   │
│   │   response = 問い合わせ()                      │   │
│   │   complete = 判定()                            │   │
│   │ }                                              │   │
│   └───────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
                          │
                          │ 境界（接続層）
                          ▼
┌─────────────────────────────────────────────────────────┐
│ 外の世界                                                 │
│                                                         │
│   LLM API / ファイル / 外部サービス                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

## 三つのフェーズ

### 1. 設定フェーズ

**いつ**: Agent 起動時、一度だけ **何を**: すべての構成を読み込み、検証する

```
入力                      出力
────                      ────
agent.json         →      AgentDefinition
steps_registry.json →     StepsRegistry
prompts/           →      PromptSet
```

**契約**:

- 設定は実行前に完結する
- 不正な設定は起動しない
- 実行中に設定は変わらない

### 2. 実行フェーズ

**いつ**: ループ中、繰り返し **何を**: プロンプト解決、LLM
問い合わせ、ステップ遷移

```
1 イテレーション
────────────────
① プロンプト解決 → ② LLM 問い合わせ → ③ 応答処理 → ④ 遷移判定
```

**契約**:

- 状態は一方向に進む（戻らない）
- 各イテレーションは独立している
- 引き継ぎは明示的に宣言する

### 3. 判定フェーズ

**いつ**: 各イテレーション終了時 **何を**: 完了条件の評価、次ステップの決定

```
判定の種類
──────────
完了判定: Agent 全体を終了するか
遷移判定: 次にどのステップへ進むか
```

**契約**:

- 判定は副作用を持たない
- 結果は実行層に返す
- 実行層が状態を更新する

## 依存の方向

```
設定
 │
 ▼
実行 ←── 判定
 │
 ▼
接続（外の世界）
```

**規則**:

- 上から下へ依存する
- 下から上へ依存しない
- 横方向の依存は限定的

## 状態管理

### 状態の所在

```
設定フェーズ: 構成データ（不変）
実行フェーズ: ループ状態、ステップ出力（可変）
判定フェーズ: 完了フラグ、遷移先（一時的）
接続層:       セッション ID（外部管理）
```

### ステップ間のデータ引き継ぎ

```
Step A             Step B             Step C
  │                  │                  │
  ▼                  ▼                  ▼
[LLM]              [LLM]              [LLM]
  │                  │                  │
  ▼                  ▼                  ▼
[抽出]             [抽出]             [抽出]
  │                  │                  │
  └───────┬──────────┴──────────┬───────┘
          ▼                     ▼
      StepContext（ステップ出力の蓄積）
          │
          ▼
      UV 変数として次ステップへ注入
```

**名前空間規則**:

```
stepId.key → uv-{stepId}_{key}

例:
measure.height → uv-measure_height
fabric.price   → uv-fabric_price
```

## エラーの分類

```
回復可能（リトライ/フォールバック）
├── 接続タイムアウト
├── レート制限
└── 一時的な外部エラー

回復不能（停止）
├── 設定エラー
├── スキーマ違反
└── ハード上限超過
```

## 複数 Agent

Agent 自体は単一ループ。並列化は外部オーケストレーターが行う。

```
┌───────────────────────────────────────────┐
│ 外部オーケストレーター                     │
│                                           │
│ 1. タスク一覧取得                          │
│ 2. 各タスクに Agent 起動                   │
│ 3. 完了待機                               │
│ 4. 結果集約                               │
└─────────────┬─────────────────────────────┘
              │
    ┌─────────┼─────────┐
    ▼         ▼         ▼
[Agent A] [Agent B] [Agent C]
```

**1:1:1:1 マッピング**:

```
1 Issue = 1 Branch = 1 Worktree = 1 Agent Instance
```

同じブランチで複数 Agent は動かない。
