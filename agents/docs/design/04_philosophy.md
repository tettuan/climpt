# 設計哲学

## Agent とは

```
Agent = 設定 + ループ + 判定
```

**設定**: 何をするか定義する **ループ**: LLM と対話しながら繰り返す **判定**:
いつ終わるか決める

これ以外は Agent の責務ではない。

## 一つの真理

**Agent は単純でなければならない**

複雑さが必要なとき、Agent を複雑にするのではなく:

- 複数の Agent に分割する
- 外部に委譲する
- 設定で切り替える

## 三つの原則

### 1. 単純さ

```
複雑な Agent は作らない
  ↓
必要なら分割する
  ↓
分割できないなら委譲する
  ↓
委譲できないなら設計を疑う
```

### 2. 境界

```
Agent の内側:
  - 設定を読む
  - プロンプトを解決する
  - LLM に問い合わせる
  - 完了を判定する

Agent の外側（委譲）:
  - Git 操作
  - GitHub 操作
  - 複数 Agent の管理
  - 外部サービス連携
  - 並列実行
```

### 3. 透明性

```
すべての状態は明示的
すべての副作用は宣言的
すべてのエラーは回復可能性を明示
```

## 禁止事項

以下は設計に含めない。例外なし。

| 禁止事項             | 理由                 | 代替手段               |
| -------------------- | -------------------- | ---------------------- |
| Agent 内並列実行     | 複雑すぎる           | 複数 Agent 起動        |
| リソースロック       | デッドロックのリスク | 外部オーケストレーター |
| 暗黙のデフォルト     | 予測困難な挙動を生む | 必須項目として明示要求 |
| 複雑なブランチ戦略   | 汎用性を損なう       | 「派生元へマージ」のみ |
| ステップ間の暗黙参照 | デバッグ困難         | 明示的な入出力宣言     |

## 成功の定義

Agent システムが成功したとき:

1. 新しい Agent を **10 分** で作れる
2. Agent の挙動がプロンプトから **予測** できる
3. エラーの原因が **3 分** で特定できる
4. 並列化が **設定変更なし** で可能（複数起動するだけ）

## 思考実験から得た教訓

222 の設計観点を発見した 5 つの思考実験:

| 実験    | 観点数 | 教訓                               |
| ------- | ------ | ---------------------------------- |
| Gecko   | 26     | ループは単純に保つ                 |
| Rudder  | 38     | 遷移ロジックを Agent から分離      |
| Saucier | 46     | 並列実行は Agent の責務ではない    |
| Welder  | 100    | 外部連携は委譲する                 |
| Tailor  | 12     | ステップ間データは明示的に引き継ぐ |

**結論**: Agent が複雑になる要求は、すべて「Agent の外側」で解決できる。
