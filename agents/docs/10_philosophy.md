# 設計哲学

Agent システムの根本原則。すべての設計判断はこの哲学に基づく。

## 核心

**Agent は「判断を伴う繰り返し」を自動化する**

```
人間: 方針を決める
Agent: 方針に従い繰り返す
人間: 結果を確認する
```

## 三原則

### 1. 単純さの原則

**複雑さは分割で解決する。Agent 自体を複雑にしない。**

```
悪い設計:
┌─────────────────────────────────────┐
│  Agent                              │
│  - 並列実行エンジン                  │
│  - リソースロック                    │
│  - 同期ポイント                      │
│  - デッドロック検出                  │
└─────────────────────────────────────┘

良い設計:
┌──────────┐ ┌──────────┐ ┌──────────┐
│ Agent A  │ │ Agent B  │ │ Agent C  │
│ (単純)   │ │ (単純)   │ │ (単純)   │
└──────────┘ └──────────┘ └──────────┘
     │            │            │
     └────────────┼────────────┘
                  ▼
         外部オーケストレーター
```

Agent は単一の仕事に集中する。並列化が必要なら複数 Agent を起動する。

### 2. 境界の原則

**Agent の責務は明確な境界内に収める。境界外は委譲する。**

```
┌─────────────────────────────────────────────────────────┐
│ Agent の境界内                                           │
│                                                         │
│   設定 → ループ → 完了判定                               │
│                                                         │
│   - 設定を読む                                           │
│   - プロンプトを解決する                                  │
│   - LLM に問い合わせる                                   │
│   - 応答を処理する                                       │
│   - 完了を判定する                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ Agent の境界外（委譲）                                    │
│                                                         │
│   - Git 操作（ブランチ、コミット、PR）                    │
│   - GitHub 操作（Issue、Project）                        │
│   - 複数 Agent の起動・待機・集約                         │
│   - 外部サービス連携                                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 3. 透明性の原則

**状態と副作用を明示する。暗黙の振る舞いを排除する。**

```typescript
// 悪い例: 暗黙の状態変更
function process(data) {
  // 何かが変わる...
}

// 良い例: 明示的な入出力
function process(input: Input): Output {
  return { ...result };
}

// 副作用が必要な場合は名前で明示
function saveToFile(data: Data): void {
  // ファイル書き込み（副作用）
}
```

## 設計の指針

### 判断基準

何かを追加するとき、以下を問う:

1. **Agent の境界内か？** → 境界外なら委譲
2. **単純さを保てるか？** → 複雑なら分割
3. **状態は明示的か？** → 暗黙なら書き直す

### レイヤー思考

抽象度の高い順に考える:

```
高 │ 何をしたいか（Why）
   │ どう実現するか（How）
低 │ 具体的な実装（What）
```

下位レイヤーの都合で上位レイヤーを変えない。
上位レイヤーが下位レイヤーを規定する。

### 拡張の方向

Agent を複雑にするのではなく、**組み合わせ方**を増やす:

```
単一 Agent     → 複数 Agent
手動起動       → 外部オーケストレーター
ファイル設定    → API 設定
ローカル実行    → リモート実行
```

## 思考実験からの教訓

210 個の設計観点を発見した 4 つの思考実験から:

### Gecko（26 観点）- 基本ループ

**教訓**: ループは単純に保つ。条件分岐はループ外に追い出す。

### Rudder（38 観点）- ステップ遷移

**教訓**: 遷移ロジックを Agent から分離する。StepMachine として独立させる。

### Saucier（46 観点）- 並列実行（スコープ外）

**教訓**: 並列実行は Agent の責務ではない。複数 Agent 起動で対応する。

### Welder（100 観点）- 複数インスタンス

**教訓**: Issue = Branch = Worktree = Instance の 1:1:1:1 対応。
派生元から分岐し、派生元にマージする。これがもっとも単純。

## 禁止事項

以下は設計に含めない:

1. **Agent 内並列実行** - 複数 Agent で代替
2. **リソースロック** - 外部オーケストレーターの責務
3. **デッドロック検出** - そもそもロックを持たない
4. **複雑なブランチ戦略** - 「派生元へマージ」のみ
5. **暗黙のデフォルト** - 必須項目は明示的に要求

## 成功の定義

Agent システムが成功したとき:

1. **新しい Agent を 10 分で作れる**
2. **Agent の挙動がプロンプトから予測できる**
3. **エラーの原因が 3 分で特定できる**
4. **並列化が設定変更なしで可能**（複数起動するだけ）
