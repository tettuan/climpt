---
c1: meta
c2: create
c3: instruction
title: Create New Climpt Instruction
description: Create a new Climpt instruction file from stdin input, following C3L specification with all required configurations
usage: climpt-meta create instruction
c3l_version: "0.5"
options:
  edition:
    - default
  adaptation:
    - default
    - detailed
  file: false
  stdin: true
  destination: true
---

# Create New Climpt Instruction

## Purpose

Create a new Climpt instruction file following the C3L specification. This process includes:
1. Naming the command according to C3L conventions
2. Creating the markdown prompt file under `.agent/climpt/prompts/`
3. Verifying/creating the executable in `.deno/bin/`
4. Verifying/updating configuration files in `.agent/climpt/config/`

## Input

This command receives input via stdin. Provide the following information through stdin:

- Purpose and description of the new instruction
- Target domain (code, git, meta, data, infra, etc.)
- Action verb (what the command does)
- Target object (what the command acts upon)

### Usage Example

```bash
# Provide input via stdin using echo or heredoc
echo "Create a command to analyze code complexity in the code domain" | climpt-meta create instruction

# Or use heredoc for multi-line input
climpt-meta create instruction << 'EOF'
Purpose: Analyze and report code complexity metrics
Domain: code
Action: analyze
Target: complexity
Description: Calculate cyclomatic complexity and provide improvement suggestions
EOF
```

The stdin input is used to determine c1 (domain), c2 (action), c3 (target) and generate the appropriate instruction file structure.

## Received Input

{input_text}

## Step 1: Find and Review C3L Specification

Before creating a new instruction, locate the latest C3L specification:

```bash
# Find the latest C3L specification document
find docs -name "c3l_specification*.md" -o -name "c3l*.md" | head -1
# Or search for C3L documentation
grep -rl "C3L.*Specification" docs/
```

Review the specification to understand:
- c1: Domain identifier (e.g., `git`, `meta`, `code`)
- c2: Action format (verb or verb-modifier)
- c3: Target format (object or object-context)

## Step 2: Naming Convention (C3L Compliant)

### c1 (Domain)

Format: `<domain>`

Common domains: `git`, `meta`, `code`, `data`, `infra`, `sec`, `test`, `docs`

The agent is specified separately in registry and MCP calls (e.g., `agent: climpt`).

Pattern: `^[a-z]+$`

### c2 (Action)

Format: `<verb>` or `<verb>-<modifier>`

Examples:
- Single: `build`, `review`, `merge`, `fetch`, `analyze`, `create`
- Compound: `group-commit`, `find-oldest`, `build-robust`

Pattern: `^[a-z]+(-[a-z]+)?$`

### c3 (Target)

Format: `<object>` or `<object>-<context>`

Examples:
- Single: `frontmatter`, `branch`, `service`, `instruction`
- Compound: `pull-request`, `unstaged-changes`, `api-service`

Pattern: `^[a-z]+(-[a-z]+)?$`

## Step 3: Create Prompt File

### Directory Structure

```
.agent/climpt/prompts/<domain>/<c2>/<c3>/
```

Example for `climpt-git group-commit unstaged-changes`:
```
.agent/climpt/prompts/git/group-commit/unstaged-changes/f_default.md
```

### File Naming

- `f_default.md` - Default edition
- `f_detailed.md` - Detailed edition (if needed)

### Generate Frontmatter

Use `climpt-meta build frontmatter` to generate C3L v0.5 compliant frontmatter:

```bash
# Generate frontmatter from stdin input
echo "Domain: code, Action: analyze, Target: complexity, Purpose: Calculate cyclomatic complexity" | climpt-meta build frontmatter

# Or use heredoc
climpt-meta build frontmatter << 'EOF'
Domain: code
Action: analyze
Target: complexity
Purpose: Calculate cyclomatic complexity and provide improvement suggestions
EOF
```

The `build frontmatter` command generates valid YAML frontmatter following C3L v0.5 specification with all required fields (c1, c2, c3, title, description, usage, options).

**IMPORTANT**: All frontmatter values MUST be in English.

### Create the File

```bash
# Create directory
mkdir -p .agent/climpt/prompts/<domain>/<c2>/<c3>/

# Create prompt file with frontmatter and content
# Write the instruction content in markdown format
```

## Step 4: Verify/Create Executable

Check if executable exists for the domain:

```bash
# Check for existing executable
ls -la .deno/bin/climpt-<domain>

# If not found, create it
cat > .deno/bin/climpt-<domain> << 'EOF'
#!/bin/sh
# generated by deno install

# Check if help or version is requested
case "$1" in
    -h|--help|-v|--version)
        exec deno run --allow-read --allow-write --allow-env --allow-run --allow-net --no-config 'jsr:@aidevtool/climpt' "$@"
        ;;
    *)
        exec deno run --allow-read --allow-write --allow-env --allow-run --allow-net --no-config 'jsr:@aidevtool/climpt' --config=<domain> "$@"
        ;;
esac
EOF

# Make executable
chmod +x .deno/bin/climpt-<domain>
```

## Step 5: Verify/Update Configuration Files

### App Configuration (.agent/climpt/config/<domain>-app.yml)

Check if exists:
```bash
ls -la .agent/climpt/config/<domain>-app.yml
```

If not exists, create:
```yaml
# Build Configuration
working_dir: ".agent/climpt"
app_prompt:
  base_dir: "prompts/<domain>"
app_schema:
  base_dir: "schema/<domain>"
```

### User Configuration (.agent/climpt/config/<domain>-user.yml)

Check if exists:
```bash
ls -la .agent/climpt/config/<domain>-user.yml
```

If exists, verify the pattern includes the new c2 (action):
```yaml
# Breakdown Configuration
params:
  two:
    directiveType:
      pattern: "^(existing-action|new-action)$"  # Add new c2 here
    layerType:
      pattern: "^(existing-target|new-target)$"  # Add new c3 here
```

If not exists, create:
```yaml
# Breakdown Configuration
params:
  two:
    directiveType:
      pattern: "^(<c2>)$"
    layerType:
      pattern: "^(<c3>)$"
```

## Step 6: Regenerate Registry

After creating all files, regenerate the registry:

```bash
deno task generate-registry
```

This updates `.agent/climpt/registry.json` with the new command.

## Step 7: Verify Tests

Run tests to ensure the new instruction is properly configured:

```bash
deno task test
```

## Output Checklist

After completion, verify the following files exist and are correct:

- [ ] `.agent/climpt/prompts/<domain>/<c2>/<c3>/f_default.md`
- [ ] `.deno/bin/climpt-<domain>` (executable, chmod +x)
- [ ] `.agent/climpt/config/<domain>-app.yml`
- [ ] `.agent/climpt/config/<domain>-user.yml` (with matching patterns)
- [ ] `.agent/climpt/registry.json` (regenerated)

## Example: Creating `climpt-data fetch stock-prices`

1. **Naming**:
   - c1: `data` (domain)
   - c2: `fetch` (action)
   - c3: `stock-prices` (target)

2. **Create prompt**:
   ```bash
   mkdir -p .agent/climpt/prompts/data/fetch/stock-prices/
   # Create f_default.md with appropriate content
   ```

3. **Create executable**:
   ```bash
   cat > .deno/bin/climpt-data << 'EOF'
   #!/bin/sh
   case "$1" in
       -h|--help|-v|--version)
           exec deno run ... 'jsr:@aidevtool/climpt' "$@"
           ;;
       *)
           exec deno run ... 'jsr:@aidevtool/climpt' --config=data "$@"
           ;;
   esac
   EOF
   chmod +x .deno/bin/climpt-data
   ```

4. **Create configs**:
   ```bash
   # data-app.yml
   working_dir: ".agent/climpt"
   app_prompt:
     base_dir: "prompts/data"
   app_schema:
     base_dir: "schema/data"

   # data-user.yml
   params:
     two:
       directiveType:
         pattern: "^(fetch)$"
       layerType:
         pattern: "^(stock-prices)$"
   ```

5. **Regenerate registry**:
   ```bash
   deno task generate-registry
   ```
